"""Malware detector implementation using signature-based detection"""

from datetime import datetime
from typing import Optional, Set, Dict, Any
from scapy.packet import Packet
from scapy.layers.inet import IP, TCP, UDP
from scapy.packet import Raw

from ids.detectors.base_detector import ThreatDetector
from ids.models.data_models import ThreatEvent, ThreatType


class MalwareDetector(ThreatDetector):
    """
    Detects malware by scanning packet payloads for known malicious signatures.
    
    Detection logic:
    - Performs signature-based detection using pattern matching on packet payloads
    - Maintains a database of common malware patterns and indicators
    - Scans both TCP and UDP packet payloads
    - Generates alerts when malicious signatures are detected
    """
    
    def __init__(self):
        """Initialize the malware detector with signature database."""
        self.signatures = self._load_signatures()
    
    def _load_signatures(self) -> Dict[str, Dict[str, Any]]:
        """
        Load malware signatures database.
        
        Returns:
            Dictionary mapping signature names to their patterns and metadata
        """
        # Common malware signatures and patterns
        # In production, this would be loaded from an external database
        signatures = {
            "wannacry_smb": {
                "pattern": b"\x00\x00\x00\x31\xff\x53\x4d\x42",
                "description": "WannaCry SMB exploit pattern",
                "severity_hint": "critical"
            },
            "emotet_payload": {
                "pattern": b"emotet",
                "description": "Emotet malware payload indicator",
                "severity_hint": "high"
            },
            "mimikatz": {
                "pattern": b"mimikatz",
                "description": "Mimikatz credential dumping tool",
                "severity_hint": "critical"
            },
            "metasploit_payload": {
                "pattern": b"metasploit",
                "description": "Metasploit framework payload",
                "severity_hint": "high"
            },
            "powershell_download": {
                "pattern": b"IEX(New-Object",
                "description": "PowerShell download cradle (common in malware)",
                "severity_hint": "high"
            },
            "base64_powershell": {
                "pattern": b"powershell -enc",
                "description": "Encoded PowerShell command (common obfuscation)",
                "severity_hint": "medium"
            },
            "reverse_shell": {
                "pattern": b"/bin/sh",
                "description": "Potential reverse shell command",
                "severity_hint": "high"
            },
            "sql_injection": {
                "pattern": b"' OR '1'='1",
                "description": "SQL injection attempt",
                "severity_hint": "high"
            },
            "xss_attack": {
                "pattern": b"<script>alert(",
                "description": "Cross-site scripting (XSS) attempt",
                "severity_hint": "medium"
            },
            "ransomware_note": {
                "pattern": b"your files have been encrypted",
                "description": "Ransomware ransom note pattern",
                "severity_hint": "critical"
            },
            "cobalt_strike": {
                "pattern": b"cobaltstrike",
                "description": "Cobalt Strike beacon indicator",
                "severity_hint": "critical"
            },
            "shellcode_nop_sled": {
                "pattern": b"\x90\x90\x90\x90\x90\x90\x90\x90",
                "description": "NOP sled (common in buffer overflow exploits)",
                "severity_hint": "high"
            }
        }
        
        return signatures
    
    def detect(self, packet: Packet) -> Optional[ThreatEvent]:
        """
        Analyze a packet payload for malware signatures.
        
        Args:
            packet: The network packet to analyze
            
        Returns:
            ThreatEvent if malware signature is detected, None otherwise
        """
        # Only process packets with IP layer and payload
        if not packet.haslayer(IP):
            return None
        
        # Check if packet has a payload (Raw layer)
        if not packet.haslayer(Raw):
            return None
        
        ip_layer = packet[IP]
        source_ip = ip_layer.src
        dest_ip = ip_layer.dst
        
        # Determine protocol
        protocol = "Unknown"
        if packet.haslayer(TCP):
            protocol = "TCP"
            dest_port = packet[TCP].dport
        elif packet.haslayer(UDP):
            protocol = "UDP"
            dest_port = packet[UDP].dport
        else:
            dest_port = None
        
        # Get packet payload
        payload = bytes(packet[Raw].load)
        
        # Convert payload to lowercase for case-insensitive matching
        payload_lower = payload.lower()
        
        # Scan payload for malware signatures
        detected_signatures = []
        for sig_name, sig_data in self.signatures.items():
            pattern = sig_data["pattern"]
            pattern_lower = pattern.lower()
            
            if pattern_lower in payload_lower:
                detected_signatures.append({
                    "name": sig_name,
                    "description": sig_data["description"],
                    "severity_hint": sig_data["severity_hint"]
                })
        
        # If malware signatures detected, create threat event
        if detected_signatures:
            current_time = datetime.now()
            
            # Get the highest severity hint from detected signatures
            severity_hints = [sig["severity_hint"] for sig in detected_signatures]
            highest_severity = self._get_highest_severity(severity_hints)
            
            threat_event = ThreatEvent(
                timestamp=current_time,
                threat_type=ThreatType.MALWARE,
                source_ip=source_ip,
                destination_ip=dest_ip,
                protocol=protocol,
                raw_data={
                    "detected_signatures": detected_signatures,
                    "signature_count": len(detected_signatures),
                    "payload_size": len(payload),
                    "destination_port": dest_port,
                    "severity_hint": highest_severity,
                    "payload_preview": self._get_payload_preview(payload)
                }
            )
            
            return threat_event
        
        return None
    
    def _get_highest_severity(self, severity_hints: list) -> str:
        """
        Determine the highest severity level from a list of severity hints.
        
        Args:
            severity_hints: List of severity hint strings
            
        Returns:
            The highest severity level as a string
        """
        severity_order = ["critical", "high", "medium", "low"]
        
        for severity in severity_order:
            if severity in severity_hints:
                return severity
        
        return "medium"  # Default
    
    def _get_payload_preview(self, payload: bytes, max_length: int = 100) -> str:
        """
        Get a safe preview of the payload for logging.
        
        Args:
            payload: The packet payload bytes
            max_length: Maximum length of preview
            
        Returns:
            String representation of payload preview
        """
        try:
            # Try to decode as UTF-8, replace invalid characters
            preview = payload[:max_length].decode('utf-8', errors='replace')
            # Replace non-printable characters with dots
            preview = ''.join(c if c.isprintable() else '.' for c in preview)
            if len(payload) > max_length:
                preview += "..."
            return preview
        except Exception:
            # If decoding fails, return hex representation
            return payload[:max_length].hex()
    
    def add_signature(self, name: str, pattern: bytes, description: str, 
                     severity_hint: str = "medium") -> None:
        """
        Add a new malware signature to the database.
        
        Args:
            name: Unique name for the signature
            pattern: Byte pattern to match
            description: Description of the malware/threat
            severity_hint: Suggested severity level (critical, high, medium, low)
        """
        self.signatures[name] = {
            "pattern": pattern,
            "description": description,
            "severity_hint": severity_hint
        }
    
    def remove_signature(self, name: str) -> bool:
        """
        Remove a signature from the database.
        
        Args:
            name: Name of the signature to remove
            
        Returns:
            True if signature was removed, False if not found
        """
        if name in self.signatures:
            del self.signatures[name]
            return True
        return False
    
    def get_signature_count(self) -> int:
        """
        Get the number of signatures in the database.
        
        Returns:
            Number of signatures
        """
        return len(self.signatures)
